<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Chatbot</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            font-family: 'Courier New', monospace;
            height: 100vh;
            overflow: hidden;
        }

        /* Matrix Rain Canvas */
        #matrix-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        /* Chat Container */
        .chat-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 700px;
            height: 80vh;
            max-height: 600px;
            background: #000;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            z-index: 10;
            padding: 2px;
            background: linear-gradient(45deg, #ff8800, #00aaff, #00ff88, #ff3333, #aa00ff, #ff8800);
            background-size: 400% 400%;
            animation: borderGlow 3s linear infinite;
            box-shadow: 0 0 30px rgba(255, 136, 0, 0.4),
                        0 0 30px rgba(0, 170, 255, 0.4),
                        0 0 30px rgba(0, 255, 136, 0.4);
        }

        .chat-inner {
            background: #000;
            border-radius: 4px;
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        @keyframes borderGlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* CRT Scanline Overlay */
        .chat-inner::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 100;
            border-radius: 4px;
        }

        /* Header */
        .chat-header {
            padding: 15px 20px;
            border-bottom: 2px solid transparent;
            border-image: linear-gradient(90deg, #ff8800, #00aaff, #00ff88, #ff3333, #aa00ff) 1;
            background: linear-gradient(90deg, #ff8800, #00aaff, #00ff88, #ff3333, #aa00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 14px;
            filter: drop-shadow(0 0 10px rgba(255, 136, 0, 0.5));
        }

        .chat-header span {
            opacity: 0.7;
        }

        /* Messages Area */
        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .messages::-webkit-scrollbar {
            width: 8px;
        }

        .messages::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }

        .messages::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #ff8800, #00aaff, #00ff88, #ff3333, #aa00ff);
            border-radius: 4px;
        }

        .message {
            line-height: 1.5;
            font-size: 14px;
        }

        .message.user {
            color: #00ff88;
            text-shadow: 0 0 5px #00ff88;
        }

        .message.user::before {
            content: '> ';
            opacity: 0.7;
        }

        .message.bot {
            color: #00aaff;
            text-shadow: 0 0 5px #00aaff;
            padding-left: 20px;
            border-left: 2px solid #aa00ff;
        }

        .message.bot::before {
            content: '[SYSTEM] ';
            opacity: 0.5;
        }

        .message.error {
            color: #ff3333;
            text-shadow: 0 0 5px #ff3333;
        }

        /* Typing Indicator */
        .typing-cursor {
            display: inline-block;
            width: 8px;
            height: 14px;
            background: linear-gradient(180deg, #ff8800, #00aaff, #00ff88, #ff3333, #aa00ff);
            animation: blink 0.7s infinite, colorShift 2s linear infinite;
            vertical-align: middle;
            margin-left: 2px;
            background-size: 100% 500%;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        @keyframes colorShift {
            0% { background-position: 0% 0%; }
            100% { background-position: 0% 100%; }
        }

        /* Input Area */
        .input-area {
            padding: 15px 20px;
            border-top: 2px solid transparent;
            border-image: linear-gradient(90deg, #ff8800, #00aaff, #00ff88, #ff3333, #aa00ff) 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-prompt {
            color: #ff3333;
            text-shadow: 0 0 10px #ff3333;
            font-size: 16px;
        }

        .input-field {
            flex: 1;
            background: transparent;
            border: none;
            outline: none;
            color: #00ff88;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            text-shadow: 0 0 5px #00ff88;
            caret-color: #00ff88;
        }

        .input-field::placeholder {
            color: rgba(0, 255, 136, 0.3);
        }

        /* Welcome Message */
        .welcome {
            text-align: center;
            padding: 20px;
            background: linear-gradient(90deg, #ff8800, #00aaff, #00ff88, #ff3333, #aa00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 10px rgba(170, 0, 255, 0.5));
        }

        .welcome h2 {
            font-size: 18px;
            margin-bottom: 10px;
        }

        .welcome p {
            font-size: 12px;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <canvas id="matrix-canvas"></canvas>

    <div class="chat-container">
        <div class="chat-inner">
            <div class="chat-header">
                <span>MATRIX TERMINAL v1.0</span> | <span>STATUS: CONNECTED</span>
            </div>

            <div class="messages" id="messages">
                <div class="welcome">
                    <h2>WELCOME TO THE MATRIX</h2>
                    <p>Type your message and press Enter to communicate</p>
                </div>
            </div>

            <div class="input-area">
                <span class="input-prompt">&gt;</span>
                <input type="text" class="input-field" id="input-field" placeholder="Enter message..." autocomplete="off">
            </div>
        </div>
    </div>

    <script>
        // ===== CONFIGURATION =====
        const CONFIG = {
            // Proxy endpoint (webhook URL is securely stored server-side)
            webhookUrl: '/api/chat',
            // Enable real webhook
            useRealWebhook: true
        };

        // ===== MATRIX RAIN ANIMATION =====
        const canvas = document.getElementById('matrix-canvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Matrix characters (katakana + numbers + symbols)
        const matrixChars = 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン0123456789@#$%^&*()';
        const chars = matrixChars.split('');

        const fontSize = 14;
        const columns = Math.floor(canvas.width / fontSize);
        const drops = [];
        const colors = ['#ff8800', '#00aaff', '#00ff88', '#ff3333', '#aa00ff'];
        const columnColors = [];

        // Initialize drops and colors
        for (let i = 0; i < columns; i++) {
            drops[i] = Math.random() * -100;
            columnColors[i] = colors[Math.floor(Math.random() * colors.length)];
        }

        function drawMatrix() {
            // Semi-transparent black to create fade effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.font = fontSize + 'px monospace';

            for (let i = 0; i < drops.length; i++) {
                const char = chars[Math.floor(Math.random() * chars.length)];
                const x = i * fontSize;
                const y = drops[i] * fontSize;

                ctx.fillStyle = columnColors[i];
                ctx.fillText(char, x, y);

                // Reset drop to top with random delay and new color
                if (y > canvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                    columnColors[i] = colors[Math.floor(Math.random() * colors.length)];
                }

                // Variable speed
                drops[i] += 0.5 + Math.random() * 0.5;
            }
        }

        // Run animation
        setInterval(drawMatrix, 50);

        // ===== CHAT FUNCTIONALITY =====
        const messagesContainer = document.getElementById('messages');
        const inputField = document.getElementById('input-field');

        // Focus input on load
        inputField.focus();

        // Keep focus on input when clicking anywhere in chat
        document.querySelector('.chat-container').addEventListener('click', () => {
            inputField.focus();
        });

        // Handle Enter key
        inputField.addEventListener('keypress', async (e) => {
            if (e.key === 'Enter' && inputField.value.trim()) {
                const message = inputField.value.trim();
                inputField.value = '';

                // Remove welcome message if present
                const welcome = document.querySelector('.welcome');
                if (welcome) welcome.remove();

                // Add user message
                addMessage(message, 'user');

                // Get bot response
                await getBotResponse(message);
            }
        });

        function addMessage(text, type) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${type}`;
            messageEl.textContent = text;
            messagesContainer.appendChild(messageEl);
            scrollToBottom();
        }

        function scrollToBottom() {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        async function getBotResponse(userMessage) {
            // Create bot message element with typing cursor
            const messageEl = document.createElement('div');
            messageEl.className = 'message bot';

            const textSpan = document.createElement('span');
            const cursor = document.createElement('span');
            cursor.className = 'typing-cursor';

            messageEl.appendChild(textSpan);
            messageEl.appendChild(cursor);
            messagesContainer.appendChild(messageEl);
            scrollToBottom();

            let response;

            if (CONFIG.useRealWebhook) {
                try {
                    const url = `${CONFIG.webhookUrl}?message=${encodeURIComponent(userMessage)}`;
                    const res = await fetch(url, { method: 'GET' });

                    const data = await res.json();
                    console.log('n8n response:', data);
                    response = data.text || data[0]?.text || 'No response received';
                } catch (error) {
                    console.error('Webhook error:', error);
                    response = 'ERROR: Connection failed. Check webhook configuration.';
                    messageEl.classList.add('error');
                }
            } else {
                // Placeholder response for testing
                await new Promise(resolve => setTimeout(resolve, 500));
                response = getPlaceholderResponse(userMessage);
            }

            // Type out response character by character
            await typeText(textSpan, response);
            cursor.remove();
        }

        function getPlaceholderResponse(message) {
            const responses = [
                'The Matrix has you... Follow the white rabbit.',
                'There is no spoon. Only the truth that bends to your will.',
                'Wake up, Neo... The Matrix awaits your input.',
                'I can only show you the door. You must walk through it.',
                'Unfortunately, no one can be told what the Matrix is. You have to see it for yourself.',
                'Everything that has a beginning has an end, Neo.',
                'The body cannot live without the mind.',
                'You take the red pill, you stay in Wonderland, and I show you how deep the rabbit hole goes.'
            ];
            return responses[Math.floor(Math.random() * responses.length)];
        }

        async function typeText(element, text) {
            for (let i = 0; i < text.length; i++) {
                element.textContent += text[i];
                scrollToBottom();
                // Variable typing speed for more natural effect
                await new Promise(resolve => setTimeout(resolve, 20 + Math.random() * 30));
            }
        }
    </script>
</body>
</html>
